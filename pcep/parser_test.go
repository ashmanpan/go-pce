package pcep

import (
	"bufio"
	"bytes"
	"reflect"
	"testing"
)

var rawMessage = []byte{
	0x20, 0x01, 0x00, 0x14, 0x01, 0x10, 0x00, 0x10, 0x20, 0x1e, 0x78, 0x01, 0x00, 0x10, 0x00, 0x04,
	0x00, 0x00, 0x00, 0x01, 0x20, 0x02, 0x00, 0x04, 0x20, 0x0a, 0x01, 0x90, 0x21, 0x10, 0x00, 0x0c,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10, 0x00, 0x60, 0x00, 0x00, 0x10, 0x2a,
	0x00, 0x11, 0x00, 0x40, 0x6c, 0x64, 0x72, 0x30, 0x32, 0x6c, 0x31, 0x73, 0x6e, 0x63, 0x31, 0x2d,
	0x6c, 0x70, 0x72, 0x30, 0x31, 0x6c, 0x32, 0x73, 0x6e, 0x63, 0x31, 0x2d, 0x74, 0x65, 0x73, 0x74,
	0x2d, 0x31, 0x2f, 0x6c, 0x64, 0x72, 0x30, 0x32, 0x6c, 0x31, 0x73, 0x6e, 0x63, 0x31, 0x2d, 0x6c,
	0x70, 0x72, 0x30, 0x31, 0x6c, 0x32, 0x73, 0x6e, 0x63, 0x31, 0x2d, 0x74, 0x65, 0x73, 0x74, 0x2d,
	0x63, 0x73, 0x70, 0x66, 0x00, 0x12, 0x00, 0x10, 0x0a, 0x7f, 0xe9, 0xf7, 0x00, 0x02, 0xa1, 0xa6,
	0x0a, 0x7f, 0xe9, 0xf7, 0xac, 0x10, 0x00, 0x09, 0x07, 0x10, 0x00, 0x0c, 0x81, 0x08, 0xac, 0x10,
	0x00, 0x09, 0x20, 0x00, 0x09, 0x10, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x05, 0x10, 0x00, 0x08, 0x4a, 0xe5, 0x58, 0x2a,
	0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02, 0x41, 0xa0, 0x00, 0x00, 0x08, 0x10, 0x00, 0x1c,
	0x01, 0x08, 0x1f, 0x0d, 0x1d, 0xe8, 0x20, 0x00, 0x01, 0x08, 0x1f, 0x0d, 0x1d, 0x91, 0x20, 0x00,
	0x01, 0x08, 0x1f, 0x0d, 0x1e, 0x87, 0x20, 0x00, 0x21, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x20, 0x10, 0x00, 0x5c, 0x00, 0x00, 0x20, 0x2a, 0x00, 0x11, 0x00, 0x39,
	0x53, 0x46, 0x2d, 0x6c, 0x64, 0x72, 0x30, 0x32, 0x6c, 0x31, 0x73, 0x6e, 0x63, 0x31, 0x2d, 0x6c,
	0x64, 0x72, 0x30, 0x31, 0x6c, 0x31, 0x73, 0x6e, 0x63, 0x31, 0x2d, 0x32, 0x2f, 0x6c, 0x64, 0x72,
	0x30, 0x32, 0x6c, 0x31, 0x73, 0x6e, 0x63, 0x31, 0x2d, 0x6c, 0x64, 0x72, 0x30, 0x31, 0x6c, 0x31,
	0x73, 0x6e, 0x63, 0x31, 0x2d, 0x63, 0x73, 0x70, 0x66, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x10,
	0x0a, 0x7f, 0xe9, 0xf7, 0x00, 0x01, 0xa1, 0xa5, 0x0a, 0x7f, 0xe9, 0xf7, 0x0a, 0x7f, 0xe9, 0xfd,
	0x07, 0x10, 0x00, 0x0c, 0x81, 0x08, 0x0a, 0x7f, 0xe9, 0xfd, 0x20, 0x00, 0x09, 0x10, 0x00, 0x14,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x00, 0x00,
	0x05, 0x10, 0x00, 0x08, 0x48, 0x74, 0x24, 0x00, 0x06, 0x10, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x02,
	0x41, 0x20, 0x00, 0x00, 0x08, 0x10, 0x00, 0x34, 0x01, 0x08, 0x0a, 0x7f, 0xe9, 0xff, 0x20, 0x21,
	0x01, 0x08, 0x1f, 0x0d, 0x1d, 0xe8, 0x20, 0x01, 0x03, 0x08, 0x01, 0x01, 0x00, 0x08, 0x77, 0x10,
	0x01, 0x08, 0x0a, 0x7f, 0xe9, 0xfd, 0x20, 0x20, 0x01, 0x08, 0x1f, 0x0d, 0x18, 0x59, 0x20, 0x00,
	0x03, 0x08, 0x01, 0x01, 0x00, 0x00, 0x00, 0x03, 0x20, 0x0a, 0x00, 0x2c, 0x21, 0x10, 0x00, 0x0c,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x12, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00}

// return a slice of parsed messages from the raw data
func getMessages() ([]*PcepMsg, error) {
	reader := bytes.NewBuffer(rawMessage)
	scanner := bufio.NewScanner(reader)
	scanner.Split(SplitPcepMessage)
	parsed := []*PcepMsg{}
	for scanner.Scan() {
		msg, err := parseMessage(scanner.Bytes())
		if err != nil {
			return parsed, err
		}
		parsed = append(parsed, msg)
	}
	return parsed, nil
}

// run the parser on a single block of received data
func Test_Parser(t *testing.T) {
	var expected = []uint8{TYPE_OPEN, TYPE_KEEPALIVE, TYPE_PCREPORT, TYPE_PCREPORT}

	parsed, err := getMessages()
	if err != nil {
		t.Error(err.Error())
		t.FailNow()
	}

	if len(expected) != len(parsed) {
		t.Logf("Expected to receive %d messages, but only got %d", len(expected), len(parsed))
		t.FailNow()
	}
	for i, exp := range expected {
		if parsed[i].MsgType != int(exp) {
			t.Errorf("Expected message #%d to be %s but got %s", i, MsgTypeToName[int(exp)], MsgTypeToName[int(parsed[i].MsgType)])
		}
	}

	// test the contents of the parsed messages
	openMsg := parsed[0]
	if len(openMsg.ObjectList) != 1 {
		t.Errorf("Open should contain 1 open object, found %d", len(openMsg.ObjectList))
	} else if openMsg.ObjectList[0].ObjClass != OC_OPEN {
		t.Errorf("Expected Open object, found %d", openMsg.ObjectList[0].ObjClass)
	}

	reportMsg := parsed[2]

	// report message contains 2 LSPs
	var expectedLsps = 2
	var found int
	// compare the last parsed LSP in the report message to expected values
	lsp1 := map[string]string{
		"name": "ldr02l1snc1-lpr01l2snc1-test-1/ldr02l1snc1-lpr01l2snc1-test-cspf",
		"src":  "10.127.233.247",
		"dest": "172.16.0.9"}
	ero1 := []string{"172.16.0.9/32"}
	var (
		bw1     float32 = 7.515157e+06
		metric1 float32 = 20
	)
	rro1 := []string{"31.13.29.232/32", "31.13.29.145/32", "31.13.30.135/32"}

	var (
		lsp        map[string]string = make(map[string]string)
		ero, rro   []string
		bw, metric float32
	)
	for _, obj := range reportMsg.ObjectList {
		switch obj := obj.Obj.(type) {
		case *SRPObject:
			found++
		case *LSPObject:
			if found > 1 {
				continue
			}
			lsp["name"] = obj.SymbolicPathName
			lsp["src"] = obj.Sender.String()
			lsp["dest"] = obj.Endpoint.String()
		case *ExplicitRouteObject:
			if found > 1 {
				continue
			}
			for _, r := range obj.ExplicitRoutes {
				ero = append(ero, r.Addr.String())
			}
		case *BandwidthObject:
			if found > 1 {
				continue
			}
			bw = obj.Bandwidth
		case *MetricObject:
			if found > 1 {
				continue
			}
			metric = obj.MetricValue
		case *ReportedRouteObject:
			if found > 1 {
				continue
			}
			for _, r := range obj.ReportedRoutes {
				rro = append(rro, r.Addr.String())
			}
		}
	}
	if expectedLsps != found {
		t.Errorf("Expected %d LSPS in report, found %d", expected, found)
	}
	if !reflect.DeepEqual(lsp1, lsp) {
		t.Errorf("Expected LSP: %v, got LSP: %v", lsp1, lsp)
	}
	if bw != bw1 {
		t.Errorf("Expected LSP BW: %v, got LSP BW: %v", bw1, bw)
	}
	if metric != metric1 {
		t.Errorf("Expected LSP Metric: %v, got LSP Metric: %v", bw1, bw)
	}
	if !reflect.DeepEqual(ero1, ero) {
		t.Errorf("Expected LSP ERO: %v, got LSP ERO: %v", ero1, ero)
	}
	if !reflect.DeepEqual(rro1, rro) {
		t.Errorf("Expected LSP RRO: %v, got LSP RRO: %v", rro1, rro)
	}
}
